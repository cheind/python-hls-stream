<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>HLS Streaming Demo</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.css" rel="stylesheet">
    <link href="https://vjs.zencdn.net/7.18.1/video-js.css" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
    <script src="https://vjs.zencdn.net/7.18.1/video.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <style>
        .header {
            text-align: center;
            margin-top: 5rem;
        }

        .container {
            max-width: 800px;
        }

        #my-video {
            margin-top: 20px;
        }

        .marker-table-anim {
            transition: background 5s linear;
        }

        .marker-table-highlight {
            background: #abebc6;
        }

        .marker-table-normal {
            background: transparent;
        }

        tr:hover {
            color: blueviolet;
            font-weight: bold;
            cursor: pointer;
        }

        .vjs-marker {
            position: absolute;
            background: red;
            width: 5px;
            height: 110%;
            top: -5%;
            z-index: 30;
            margin-left: -3px;
        }

        .vjs-marker:hover span {
            opacity: 1;
        }

        .vjs-marker span {
            position: absolute;
            bottom: 15px;
            opacity: 0;
            margin-left: -20px;
            z-index: 90;
            background: rgba(0, 0, 0, .8);
            padding: 8px;
            font-size: 10px;
        }

        .author {
            font-size: small;
            text-align: right;
        }
    </style>
</head>

<body>
    <div class="container">
        <section class="header">
            <h2>HLS Streaming with timeline-markers.</h2>
            <p style="text-align:justify; margin-bottom: 1rem;">Shown below, is a real-time generated HLS stream of a
                rolling checkerboard
                pattern.
                Ocassionally an event (mint square) is emitted that leads to markers being added
                to the table and the timeline. Depending on the HLS configuration you can leave the live edge
                and seek backwards in time.</p>
            <p class="author">
                Christoph Heindl<br />
                <a href="https://github.com/cheind/python-hls-stream">https://github.com/cheind/python-hls-stream</a>
            </p>
        </section>

        <div class="row">
            <div class="eight columns">
                <video id="my-video" class="video-js vjs-fluid" controls autoplay muted preload="auto">
                    <source src="//127.0.0.1:5000/video/chessboard.m3u8" type="application/x-mpegURL">
                </video>

            </div>
            <div class="four columns">
                <table class="u-full-width">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Text</th>
                        </tr>
                    </thead>
                    <tbody id="tbodymarkers"></tbody>
                </table>
            </div>
        </div>

    </div>
</body>
<script>


    var markers = [];
    var video = null;
    var tech = null;

    function endpoints(media) {
        const tracker = video.liveTracker;
        const segments = media.segments;
        const last = segments[segments.length - 1];
        const first = segments[0];

        const duration = media.targetDuration;
        const seq = media.mediaSequence;
        const lt = video.liveTracker

        let low = duration * seq;
        let seglengths = segments.reduce(function (prev, seg) {
            return prev + seg.duration;
        }, 0.0);
        let high = seglengths + low

        if (tracker.isLive()) {
            high = low + tracker.liveWindow();
        } else {
            low = high - tracker.liveWindow();
        }

        low_dt = new Date(low * 1000).toISOString().substr(11, 8)
        low_high = new Date(high * 1000).toISOString().substr(11, 8)
        //console.log('low', low_dt, 'high', low_high, tracker.isLive(), tracker.liveWindow());
        return {
            'low': low,
            'high': high,
        };
    }

    function animate_timeline_markers() {
        if (!tech) {
            // will be attached at some point in time.
            // TODO: is there an event for this?
            tech = video.tech();
            return;
        }

        const media = tech.vhs.playlists.media();
        if (!media) {
            // Media is also attached asynchrously.            
            return;
        }

        // Query the endpoints of the timeline.
        const ep = endpoints(media);

        // Add markers to the timeline.
        // TODO: Consider VTT and chapters, this would get rid of all the code below.
        var pbar = jQuery(video.controlBar.progressControl.children_[0].el_);

        for (var i = 0; i < markers.length; i++) {
            const pts = markers[i].time
            const pending = pts > ep.high;
            const lost = pts < ep.low;
            // Convert pts to relative timeline pos
            const left = (markers[i].time - ep.low) / (ep.high - ep.low);

            // We store a jQuery object with the marker.
            if (!markers[i]['el']) {
                // First time creation
                var el = jQuery('<div class="vjs-marker" style="left:100%" data-time="' + markers[i].time + '"><span>' + markers[i].text + '</span></div>');
                pbar.append(el);
                markers[i]['el'] = el;
            }

            // update position
            el = markers[i].el;
            el.css({
                'left': left * 100 + '%', 'visibility': !(pending || lost) ? 'visible' : 'hidden'
            });
        }

    }

    /**
     * request-animation-frame loop
     */
    function animate_markers() {
        animate_timeline_markers();
        requestAnimationFrame(animate_markers);
    }


    /**
     * This function updates the markers list using the web API.
     */
    var update_markers = function () {
        // We query markers starting from the lastest marker we
        // already know.
        data = { 'ts_start': -1.0 }
        if (markers.length > 0) {
            data['ts_start'] = markers[markers.length - 1]['time']
        }

        // Start querying API
        return $.ajax({
            'type': 'get',
            'url': '//127.0.0.1:5000/markers',
            'data': data
        }).then(function (results) {
            results = JSON.parse(results);

            // Iterate markers and generate a table entry
            // Each marker has text and time. Time [sec] corresponds 
            // to absolute stream time, i.e zero is when the stream started.
            new_markers = results['markers']
            new_markers.forEach(function (m) {
                let dt = new Date(m['time'] * 1000).toISOString().substr(11, 8)
                let id = "marker-table-" + Math.ceil(m['time']);
                console.log(id)
                $("<tr id='" + id + "' class='marker-table-anim marker-table-highlight'><td>" + dt + '</td><td>' + m['text'] + "</td></tr>")
                    .hide()
                    .prependTo($("#tbodymarkers"))
                    .fadeIn('slow', function () {
                        // Once animation is complete, remove it
                        $('#' + id).removeClass("marker-table-anim");
                        $('#' + id).removeClass("marker-table-highlight");
                    })
                    .addClass('marker-table-normal')
                    .click(function () {
                        let ep = endpoints(tech.vhs.playlists.media());
                        let seek = tech.vhs.stats.seekable[0]
                        // convert from hls ep -> time on timeline?
                        k = (ep.low - ep.high) / (seek.start - seek.end)
                        d = seek.start - k * ep.low
                        video.currentTime(m['time'] * k + d);
                    });
            });

            // Limite the number of markers to the latest N.
            markers = markers.concat(new_markers)
            $("#tbodymarkers > tr").each(function () {
                if ($(this).index() >= 5) {
                    $(this).hide();
                }
            });
        });
    }



    $(document).ready(function () {
        video = videojs('my-video', {
            liveui: true,
            inactivityTimeout: 0,
            html5: {
                nativeAudioTracks: false,
                nativeVideoTracks: false,
                vhs: {
                    debug: true,
                    overrideNative: true
                }
            }
        });
        video.play();
        update_markers();
        animate_markers();
    });
    var intervalId2 = setInterval(update_markers, 5000);


</script>

</html>